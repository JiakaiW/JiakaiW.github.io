<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SC-qubit</title>
    <link rel="stylesheet" href="/styles.css">
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const theme = localStorage.getItem('theme');
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                document.getElementById('theme-toggle').textContent = 'Light Mode';
            }
        });

        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('dark-mode');
            const themeToggle = document.getElementById('theme-toggle');
            if (body.classList.contains('dark-mode')) {
                themeToggle.textContent = 'Light Mode';
                localStorage.setItem('theme', 'dark');
            } else {
                themeToggle.textContent = 'Dark Mode';
                localStorage.setItem('theme', 'light');
            }
        }
    </script>
    <style>
        footer {
            display: block;
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #f1f1f1;
            text-align: center;
            padding: 10px;
        }
        .gallery-wrapper {
            position: relative;
            text-align: center;
        }
        .gallery-container {
            overflow: hidden;
            white-space: nowrap;
            display: inline-block;
        }
        .gallery-item {
            display: inline-block;
            margin: 0 10px;
            transition: transform 0.5s ease;
        }
        .gallery-arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 10px;
            cursor: pointer;
            z-index: 1;
        }
        .gallery-arrow.left {
            left: 10px;
        }
        .gallery-arrow.right {
            right: 10px;
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><button onclick="location.href='/'">Home</button></li>
                <li><button onclick="location.href='/sc-qubit/'">SC-qubit</button></li>
                <li><button onclick="location.href='/qec/'">QEC</button></li>
                <li><button onclick="location.href='/hpc/'">HPC</button></li>
                <li><button onclick="location.href='/ai/'">AI</button></li>
                <li><button onclick="location.href='/publications-talks/'">Publications/Talks</button></li>
            </ul>
        </nav>
        <button id="theme-toggle" onclick="toggleTheme()">Dark Mode</button>
    </header>
    <main>
        <h1 id="analytical-and-numerical-studies-on-superconducting-qubits">Analytical and numerical studies on superconducting qubits</h1>
<div style="text-align: right;">
    -- for the entertainment of my experimentalist friends
</div>

<hr />

<h1 id="1-the-fluxonium-erasure-qubit-project">1. The fluxonium erasure qubit project:</h1>

<p><a href="/files/2024/APSMM24_fluxonium.pdf">APS March Meeting 2024 Fluxonium leakage detection, https://meetings.aps.org/Meeting/MAR24/Session/A49.8</a></p>

<p><a href="/files/2024/leakage_detection_poster.pdf">IMSI quantum hardware workshop poster 2024</a></p>

<h3 id="-paper-coming-soon">ðŸ˜‚ Paper coming soon</h3>

<h3 id="summary-we-demonstrate-a-single-fluxonium-artificial-atom-can-be-used-as-an-erasure-qubit-previous-proposals-for-superconducting-erasure-qubits-are-all-composite-like-dual-rail-transmon-or-fluxonium-molecule">Summary: We demonstrate a single fluxonium artificial atom can be used as an erasure qubit! Previous proposals for superconducting erasure qubits are all composite, like dual-rail transmon or fluxonium molecule.</h3>

<div style="text-align: center;">

<img src="/files/2024/fluxonium.png" style="width: 500px;" alt="qubit level structure" />
<p>In this project, we utilize the selection rule in <a href="https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.5.040318">integer fluxonium</a> to enhance the computational subspace coherence time and do trade-off with leakage process.</p>

</div>

<h2 id="a-two-outcome-leakage-detection-measurement-via-tunable-resonator">a) Two-outcome leakage detection measurement via tunable resonator</h2>

<div style="text-align: center;">
  <img src="/files/2024/readout.png" style="width: 800px;" alt="leakage detection diagram" />
  <p>Dispersive readout can be used to detect leakage without harming qubit coherence in fluxonium! See analytical and numerical analysis on dephasing in the coming paper. </p>
</div>

<h2 id="b-two-outcome-leakage-detection-measurement-via-transmon">b) Two-outcome leakage detection measurement via transmon</h2>

<div style="text-align: center;">
  <img src="/files/2024/tmon.png" style="width: 500px;" alt="leakage detection diagram" />
  <p>By adjusting transmon frequency and drive amplitude, we get another "degree of freedom" in the control compared to resonator based readout, making leakage detection less demanding on parameter selection. </p>
</div>

<h2 id="c-erasure-preserving-gates">c) Erasure-preserving gates</h2>

<div style="text-align: center;">
<img src="/files/2024/raman.png" style="width: 800px;" alt="raman gate that preserve erasure-dominant error structure" />
<p>Coherence time estimation shows that g-f <u>I</u>nteger<u> F</u>luxonium<u> Q</u>ubit (g-f IFQ) is an erasure-dominant qubit with super-long computational subspace coherence time, this feature needs to be preserve in gate operations. We show that by using large enough detuning, intermediate state decay is minimized, and additional leakage can be converted to erasure by the aforementioned leakage detection measurement via transmon. This established g-f IFQ as an erasure qubit.</p>
</div>


    </main>
    <footer id="footer">
        &copy; 2024 Jiakai Wang
    </footer>
    <script>
        document.addEventListener('scroll', function() {
            const footer = document.getElementById('footer');
            if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 10) {
                footer.style.display = 'block';
            } else {
                footer.style.display = 'none';
            }
        });

        function scrollGallery(direction) {
            const container = document.querySelector('.gallery-container');
            const itemWidth = container.querySelector('.gallery-item').offsetWidth + 20; // 20 is the margin
            container.scrollBy({ left: direction * itemWidth, behavior: 'smooth' });
        }
    </script>
</body>
</html>