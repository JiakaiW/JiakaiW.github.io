<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="viewport" content="width=device-width, initial-scale=0.7">
    <title>Fluxonium Erasure Qubit</title>
    <link rel="stylesheet" href="/styles.css">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
    <link rel="manifest" href="/assets/site.webmanifest">
    <script src="https://unpkg.com/lunr/lunr.js"></script>
    <script>
        // Initialize search index
        let searchIndex;
        let searchData;

        // Fetch and build search index
        async function initSearch() {
            try {
                const response = await fetch('/assets/search-index.json');
                searchData = await response.json();
                
                // Build Lunr index
                searchIndex = lunr(function() {
                    this.ref('url');
                    this.field('title');
                    this.field('content');
                    
                    searchData.forEach(doc => {
                        this.add(doc);
                    });
                });
            } catch (error) {
                console.error('Error initializing search:', error);
            }
        }

        // Initialize search when the page loads
        document.addEventListener('DOMContentLoaded', initSearch);

        document.addEventListener('DOMContentLoaded', function() {
            // Always use dark mode
            document.body.classList.add('dark-mode');

            // Add prefix to figure captions
            let figIdx = 1;
            document.querySelectorAll('img').forEach(img => {
                const caption = img.nextElementSibling;
                if (caption && caption.tagName.toLowerCase() === 'p') {
                    caption.classList.add('figure-caption');
                    caption.textContent = `Fig. ${figIdx++}: ${caption.textContent}`;
                }
            });
        });

        function scrollGallery(direction) {
            const container = document.querySelector('.gallery-container');
            const itemWidth = container.querySelector('.gallery-item').offsetWidth + 20; // 20 is the margin
            const scrollAmount = direction * itemWidth;
            container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
        }

        async function expandCard(cardId) {
            const overlay = document.getElementById('cardOverlay');
            const content = document.getElementById('expandedContent');
            
            try {
                // Determine the correct path based on the cardId
                let fetchPath;
                if (cardId.includes('past_projects')) {
                    fetchPath = `/${cardId}/`;
                } else {
                    fetchPath = `/potential_directions/${cardId}/`;
                }
                
                // Fetch the content
                const response = await fetch(fetchPath);
                const html = await response.text();
                
                // Extract the main content
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const mainContent = doc.querySelector('main').innerHTML;
                
                // Insert the content
                content.innerHTML = mainContent;
                
                // Show the overlay
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent scrolling
                
                // Reset scroll position
                const expandedCard = overlay.querySelector('.expanded-card');
                if (expandedCard) {
                    expandedCard.scrollTop = 0;
                }
            } catch (error) {
                console.error('Error loading content:', error);
            }
        }

        function closeExpandedCard() {
            const overlay = document.getElementById('cardOverlay');
            overlay.classList.remove('active');
            document.body.style.overflow = ''; // Restore scrolling
        }
    </script>
    <style>
        footer {
            display: block;
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: #f1f1f1;
            text-align: center;
            padding: 10px;
        }
        .gallery-wrapper {
            position: relative;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .gallery-container {
            overflow: hidden;
            white-space: nowrap;
            display: inline-block;
        }
        .gallery-item {
            display: inline-block;
            margin: 0 10px;
            transition: transform 0.5s ease;
        }
        .gallery-arrow {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 10px;
            cursor: pointer;
            z-index: 1;
        }
        .gallery-arrow.left {
            margin-right: 10px;
        }
        .gallery-arrow.right {
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <ul>
                <li class="menu-link">
                    <a href="/">Home</a>
                    <div class="dropdown-content">
                        <a href="/#about">About Me</a>
                        <a href="/#featured-projects">Featured Projects</a>
                        <a href="/#research-interests">Research Interests</a>
                    </div>
                </li>
                <li class="menu-link">
                    <a href="/photos.html">Photos</a>
                    <div class="dropdown-content">
                        <a href="/photos.html">Photo Gallery</a>
                    </div>
                </li>
                <li class="menu-link">
                    <a href="/publications-talks/">Publications/Talks</a>
                    <div class="dropdown-content">
                        <a href="/publications-talks/#publications">Publications</a>
                        <a href="/publications-talks/#talks">Conference Talks</a>
                        <a href="/publications-talks/#posters">Research Posters</a>
                    </div>
                </li>
            </ul>
        </nav>
        <div class="search-button">
            <a href="#" onclick="toggleSearch(); return false;">üîçÔ∏é</a>
        </div>
    </header>

    <!-- Search Overlay -->
    <div class="search-overlay" id="searchOverlay" onclick="closeSearch()">
        <div class="search-container" onclick="event.stopPropagation()">
            <input type="text" 
                   class="search-input" 
                   id="searchInput" 
                   placeholder="Start typing to search..."
                   oninput="handleSearch(event)">
            <div class="search-results" id="searchResults"></div>
        </div>
    </div>

    <main>
        <h1 id="fluxonium-erasure-qubit">Fluxonium erasure qubit</h1>

<p><strong>Why erasure qubit:</strong> At the same total error rate, erasure errors that are mostly heralded (of known location) are easier to correct, and gives rise to higher threshold and larger logical error suppression exponent. While erasure qubits have been demonstrated on natural atoms or composite superconducting qubits, it will be cool if erasure qubit can be implemented on single-mode superconducting qubits.</p>

<p><strong>We demonstrate that a single fluxonium artificial atom can be used as an erasure qubit, along with proposals for physical gates</strong></p>
<h3 id="paper-coming-soon">Paper coming soon</h3>

<p><a href="/files/2024/APSMM24_fluxonium.pdf">APS March Meeting 2024 Fluxonium leakage detection, https://meetings.aps.org/Meeting/MAR24/Session/A49.8</a></p>

<p><a href="/files/2024/leakage_detection_poster.pdf">IMSI quantum hardware workshop poster 2024</a></p>

<div style="text-align: center;">

<img src="/files/2024/fluxonium.png" style="width: 500px;" alt="qubit level structure" />
<p>Fluxonium has a more complex potential and selection rules than transmon. We utilize the selection rule in <a href="https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.5.040318">integer fluxonium</a> to enhance the computational subspace coherence time and do trade-off with leakage process.</p>

</div>

<h2 id="a-two-outcome-leakage-detection-measurement-via-tunable-resonator">a) Two-outcome leakage detection measurement via tunable resonator</h2>

<div style="text-align: center;">
  <img src="/files/2024/readout.png" style="width: 800px;" alt="leakage detection diagram" />
  <p>Dispersive readout can be used to detect leakage without harming qubit coherence in fluxonium. See analytical and numerical analysis on dephasing in the coming paper. </p>
</div>

<h2 id="b-two-outcome-leakage-detection-measurement-via-transmon">b) Two-outcome leakage detection measurement via transmon</h2>

<div style="text-align: center;">
  <img src="/files/2024/tmon.png" style="width: 500px;" alt="leakage detection diagram" />
  <p>By adjusting non-linear resonator frequency and drive amplitude, we get another "degree of freedom" in the control compared to resonator based readout, making leakage detection less demanding on parameter selection. </p>
</div>

<h2 id="c-erasure-bias-preserving-gates">c) ‚ÄúErasure-bias‚Äù preserving gates</h2>

<div style="text-align: center;">
<img src="/files/2024/raman.png" style="width: 800px;" alt="raman gate that preserve erasure-dominant error structure" />
<p>Coherence time estimation shows that g-f <u>I</u>nteger<u> F</u>luxonium<u> Q</u>ubit (g-f IFQ) is an erasure-dominant qubit with super-long computational subspace coherence time, this feature needs to be preserve in gate operations. We show that by using large enough detuning, intermediate state decay is minimized, and additional leakage can be converted to erasure by the aforementioned leakage detection measurement via transmon. This established g-f IFQ as an erasure qubit.</p>
</div>

    </main>
    <footer id="footer">
        &copy; 2024 Jiakai Wang
    </footer>
    <script>
        // Search functionality
        let searchDebounceTimeout;

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Open search on CMD/CTRL + K
            if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                e.preventDefault();
                toggleSearch();
            }
            // Close search or expanded card on Escape
            if (e.key === 'Escape') {
                // Check if search is active
                const searchOverlay = document.getElementById('searchOverlay');
                if (searchOverlay.classList.contains('search-active')) {
                    closeSearch();
                }
                // Check if card is expanded
                const cardOverlay = document.getElementById('cardOverlay');
                if (cardOverlay.classList.contains('active')) {
                    closeExpandedCard();
                }
            }
        });

        function handleSearch(event) {
            const query = event.target.value;
            
            // Clear previous timeout
            clearTimeout(searchDebounceTimeout);
            
            // Set new timeout (300ms debounce)
            searchDebounceTimeout = setTimeout(() => {
                if (!query.trim()) {
                    document.getElementById('searchResults').innerHTML = '';
                    return;
                }

                try {
                    // Perform search
                    const results = searchIndex.search(query);
                    const resultsContainer = document.getElementById('searchResults');
                    
                    if (results.length === 0) {
                        resultsContainer.innerHTML = '<div class="search-no-results">No results found</div>';
                        return;
                    }

                    // Format and display results
                    const formattedResults = results
                        .slice(0, 10) // Limit to top 10 results
                        .map(result => {
                            const doc = searchData.find(d => d.url === result.ref);
                            const preview = doc.content.substring(0, 150) + '...';
                            return `
                                <div class="search-result-item">
                                    <a href="${doc.url}">
                                        <h3>${doc.title}</h3>
                                        <p>${preview}</p>
                                    </a>
                                </div>
                            `;
                        })
                        .join('');

                    resultsContainer.innerHTML = formattedResults;
                } catch (error) {
                    console.error('Search error:', error);
                    document.getElementById('searchResults').innerHTML = 
                        '<div class="search-error">An error occurred while searching</div>';
                }
            }, 300); // 300ms debounce delay
        }

        function toggleSearch() {
            const overlay = document.getElementById('searchOverlay');
            const searchInput = document.getElementById('searchInput');
            const isActive = overlay.classList.contains('search-active');
            
            overlay.classList.toggle('search-active');
            document.querySelector('.search-container').classList.toggle('search-active');
            
            if (!isActive) {
                searchInput.focus();
            }
        }

        function closeSearch() {
            document.getElementById('searchOverlay').classList.remove('search-active');
            document.querySelector('.search-container').classList.remove('search-active');
            document.getElementById('searchResults').innerHTML = '';
        }

        document.addEventListener('scroll', function() {
            const footer = document.getElementById('footer');
            if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 10) {
                footer.style.display = 'block';
            } else {
                footer.style.display = 'none';
            }
        });
    </script>
    <!-- Card Expansion Overlay -->
    <div class="card-overlay" id="cardOverlay" onclick="closeExpandedCard()">
        <div class="expanded-card-container">
            <div class="expanded-card" onclick="event.stopPropagation()">
                <button class="close-button" onclick="closeExpandedCard()">√ó</button>
                <div class="expanded-content" id="expandedContent">
                    <!-- Content will be loaded here -->
                </div>
            </div>
        </div>
    </div>
</body>
</html>